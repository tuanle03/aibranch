#!/usr/bin/env node
var I=Object.defineProperty;var r=(e,a)=>I(e,"name",{value:a,configurable:!0});import{command as m,cli as _}from"cleye";import{cyan as p,yellow as k,green as x,dim as g,red as B}from"kolorist";import*as t from"@clack/prompts";import{execa as i}from"execa";import{generateText as O}from"ai";import{openai as S}from"@ai-sdk/openai";import{homedir as N}from"os";import{join as P}from"path";import{writeFileSync as F,existsSync as G,readFileSync as R}from"fs";import w from"ini";const T=r(async()=>{try{const{stdout:e}=await i("git",["diff","--cached"]);return e}catch{const{stdout:e}=await i("git",["diff"]);return e}},"getGitDiff"),K=r(async()=>{const{stdout:e}=await i("git",["status","--short"]);return e},"getGitStatus"),j=r(async()=>{const{stdout:e}=await i("git",["rev-parse","--abbrev-ref","HEAD"]);return e},"getCurrentBranch"),U=r(async(e=5)=>{const{stdout:a}=await i("git",["log",`-${e}`,"--pretty=format:%s"]);return a.split(`
`)},"getRecentCommits"),Y=r(async(e,a=!0)=>{a?await i("git",["checkout","-b",e]):await i("git",["branch",e])},"createBranch"),D=r(async()=>{try{return await i("git",["rev-parse","--git-dir"]),!0}catch{return!1}},"isGitRepository"),d=P(N(),".aibranch");async function u(){if(!G(d))return{};const e=R(d,"utf-8");return w.parse(e)}r(u,"getConfig");async function L(){return u()}r(L,"getAllConfig");async function h(e,a){const n=await u();n[e]=a,F(d,w.stringify(n))}r(h,"setConfig");async function H(e){const a=await u(),n=`You are a Git branch naming expert. Generate ${e.count} professional, descriptive branch names based on the following context.

Branch Type: ${e.type}
${e.description?`Task Description: ${e.description}`:""}

Git Context:
${e.context}

Requirements:
- Follow format: ${e.type}/descriptive-name-with-hyphens
- Use lowercase and hyphens only
- Be concise but descriptive (max 50 characters)
- Follow conventional naming: feature/, bugfix/, hotfix/, release/
- Examples: feature/user-authentication, bugfix/fix-login-error

Generate ${e.count} branch name suggestions. Return ONLY the branch names, one per line, without numbers or additional text.`,o=S(a.OPENAI_MODEL||"gpt-4o-mini",{apiKey:a.OPENAI_API_KEY,baseURL:a.OPENAI_BASE_URL}),{text:s}=await O({model:o,prompt:n,temperature:.7,maxTokens:200});return s.split(`
`).map(c=>c.trim()).filter(c=>c&&!c.match(/^\d+\./)).slice(0,e.count)}r(H,"generateBranchNames");async function M(e){await D()||(t.cancel("Not a git repository!"),process.exit(1)),(await u()).OPENAI_API_KEY||(t.cancel("Please run `aibranch setup` first to configure your API key"),process.exit(1)),t.intro(p("\u{1F33F} AI Branch Name Generator"));let n=e.description;n||(n=await t.text({message:"What is this branch for?",placeholder:"e.g., Add user authentication feature"}),t.isCancel(n)&&(t.cancel("Operation cancelled"),process.exit(0)));let o=e.type;(!o||o==="feature")&&(o=await t.select({message:"Select branch type:",options:[{value:"feature",label:"Feature - New feature"},{value:"bugfix",label:"Bugfix - Bug fix"},{value:"hotfix",label:"Hotfix - Urgent fix"},{value:"release",label:"Release - Release branch"},{value:"custom",label:"Custom - Enter custom type"}]}),t.isCancel(o)&&(t.cancel("Operation cancelled"),process.exit(0)),o==="custom"&&(o=await t.text({message:"Enter custom branch type:",placeholder:"e.g., experiment, test"})));const s=t.spinner();s.start("Generating branch names with AI...");try{const[c,v,C,A]=await Promise.all([T().catch(()=>""),K().catch(()=>""),j().catch(()=>"main"),U().catch(()=>[])]),$=`
Current Branch: ${C}
Recent Commits: ${A.join(", ")}
Git Status: ${v}
${c?`Recent Changes:
${c.slice(0,1e3)}`:""}
    `.trim(),E=await H({context:$,description:n,type:o,count:e.generate||3});s.stop("Branch names generated!");const f=await t.select({message:"Select a branch name:",options:[...E.map(b=>({value:b,label:b})),{value:"__custom__",label:k("\u270F\uFE0F  Enter custom name")}]});t.isCancel(f)&&(t.cancel("Operation cancelled"),process.exit(0));let l=f;f==="__custom__"&&(l=await t.text({message:"Enter branch name:",placeholder:"feature/my-custom-branch"}));const y=e.create||await t.confirm({message:`Create and checkout branch "${l}"?`});t.isCancel(y)&&(t.cancel("Operation cancelled"),process.exit(0)),y?(await Y(l,!0),t.outro(x(`\u2713 Created and checked out branch: ${l}`))):t.outro(`Branch name: ${p(l)}`)}catch(c){s.stop("Failed to generate branch names"),t.cancel(c.message),process.exit(1)}}r(M,"generateBranchCommand");const q=m({name:"setup",description:"Setup AI provider configuration"},async()=>{t.intro("\u{1F527} AI Branch Setup");const e=await t.select({message:"Select AI provider:",options:[{value:"openai",label:"OpenAI"},{value:"togetherai",label:"TogetherAI (recommended)"},{value:"ollama",label:"Ollama (local)"},{value:"custom",label:"Custom OpenAI-compatible"}]});t.isCancel(e)&&(t.cancel("Setup cancelled"),process.exit(0));const a=await t.text({message:"Enter your API key:",placeholder:"sk-..."});t.isCancel(a)&&(t.cancel("Setup cancelled"),process.exit(0)),await h("OPENAI_API_KEY",a),await h("provider",e),t.outro("\u2713 Configuration saved!")}),W=m({name:"get",parameters:["<key>"],description:"Get a configuration value"},async e=>{const a=await u(),n=e._.key,o=a[n];console.log(o===void 0?g(`Config key "${n}" not found`):o)}),z=m({name:"set",parameters:["<key=value>"],description:"Set a configuration value"},async e=>{const a=e._,n=a["key=value"]||Object.values(a)[0];(!n||typeof n!="string")&&(console.error("Invalid format. Use: aibranch config set key=value"),process.exit(1));const[o,...s]=n.split("="),c=s.join("=");(!o||c===void 0||c==="")&&(console.error("Invalid format. Use: aibranch config set key=value"),process.exit(1)),await h(o,c),console.log(x(`\u2713 Set ${o}=${c}`))}),J=m({name:"config",description:"Manage configuration",commands:[W,z]},async()=>{const e=await L();if(Object.keys(e).length===0){console.log(g("No configuration found. Run `aibranch setup` first."));return}console.log(p("Current configuration:")),console.log("");for(const[a,n]of Object.entries(e))a.includes("KEY")||a.includes("TOKEN")?console.log(`  ${a}: ${g("***"+n.slice(-4))}`):console.log(`  ${a}: ${n}`)}),Q=_({name:"aibranch",version:"1.0.0",commands:[q,J],flags:{generate:{type:Number,alias:"g",description:"Number of branch names to generate",default:3},description:{type:String,alias:"d",description:"Description of what the branch is for"},type:{type:String,alias:"t",description:"Branch type (feature/bugfix/hotfix/release)",default:"feature"},create:{type:Boolean,alias:"c",description:"Automatically create the selected branch",default:!1}}}),{flags:V,command:X}=Q;if(!X)try{await M(V)}catch(e){console.error(B("Error:"),e.message),process.exit(1)}
