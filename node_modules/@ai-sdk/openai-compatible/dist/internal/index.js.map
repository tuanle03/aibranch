{"version":3,"sources":["../../src/internal/index.ts","../../src/chat/convert-to-openai-compatible-chat-messages.ts","../../src/chat/map-openai-compatible-finish-reason.ts","../../src/chat/get-response-metadata.ts"],"sourcesContent":["export { convertToOpenAICompatibleChatMessages } from '../chat/convert-to-openai-compatible-chat-messages';\nexport { mapOpenAICompatibleFinishReason } from '../chat/map-openai-compatible-finish-reason';\nexport { getResponseMetadata } from '../chat/get-response-metadata';\nexport type { OpenAICompatibleChatConfig } from '../chat/openai-compatible-chat-language-model';\n","import {\n  LanguageModelV3Prompt,\n  SharedV3ProviderMetadata,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { OpenAICompatibleChatPrompt } from './openai-compatible-api-types';\nimport { convertToBase64 } from '@ai-sdk/provider-utils';\n\nfunction getOpenAIMetadata(message: {\n  providerOptions?: SharedV3ProviderMetadata;\n}) {\n  return message?.providerOptions?.openaiCompatible ?? {};\n}\n\nfunction getAudioFormat(mediaType: string): 'wav' | 'mp3' | null {\n  switch (mediaType) {\n    case 'audio/wav':\n      return 'wav';\n    case 'audio/mp3':\n    case 'audio/mpeg':\n      return 'mp3';\n    default:\n      return null;\n  }\n}\n\nexport function convertToOpenAICompatibleChatMessages(\n  prompt: LanguageModelV3Prompt,\n): OpenAICompatibleChatPrompt {\n  const messages: OpenAICompatibleChatPrompt = [];\n  for (const { role, content, ...message } of prompt) {\n    const metadata = getOpenAIMetadata({ ...message });\n    switch (role) {\n      case 'system': {\n        messages.push({ role: 'system', content, ...metadata });\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0].type === 'text') {\n          messages.push({\n            role: 'user',\n            content: content[0].text,\n            ...getOpenAIMetadata(content[0]),\n          });\n          break;\n        }\n\n        messages.push({\n          role: 'user',\n          content: content.map(part => {\n            const partMetadata = getOpenAIMetadata(part);\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text, ...partMetadata };\n              }\n              case 'file': {\n                if (part.mediaType.startsWith('image/')) {\n                  const mediaType =\n                    part.mediaType === 'image/*'\n                      ? 'image/jpeg'\n                      : part.mediaType;\n\n                  return {\n                    type: 'image_url',\n                    image_url: {\n                      url:\n                        part.data instanceof URL\n                          ? part.data.toString()\n                          : `data:${mediaType};base64,${convertToBase64(part.data)}`,\n                    },\n                    ...partMetadata,\n                  };\n                }\n\n                if (part.mediaType.startsWith('audio/')) {\n                  if (part.data instanceof URL) {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: 'audio file parts with URLs',\n                    });\n                  }\n\n                  const format = getAudioFormat(part.mediaType);\n                  if (format === null) {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: `audio media type ${part.mediaType}`,\n                    });\n                  }\n\n                  return {\n                    type: 'input_audio',\n                    input_audio: {\n                      data: convertToBase64(part.data),\n                      format,\n                    },\n                    ...partMetadata,\n                  };\n                }\n\n                if (part.mediaType === 'application/pdf') {\n                  if (part.data instanceof URL) {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: 'PDF file parts with URLs',\n                    });\n                  }\n\n                  return {\n                    type: 'file',\n                    file: {\n                      filename: part.filename ?? 'document.pdf',\n                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`,\n                    },\n                    ...partMetadata,\n                  };\n                }\n\n                if (part.mediaType.startsWith('text/')) {\n                  const textContent =\n                    part.data instanceof URL\n                      ? part.data.toString()\n                      : typeof part.data === 'string'\n                        ? part.data\n                        : new TextDecoder().decode(part.data);\n\n                  return {\n                    type: 'text',\n                    text: textContent,\n                    ...partMetadata,\n                  };\n                }\n\n                // Unsupported type\n                throw new UnsupportedFunctionalityError({\n                  functionality: `file part media type ${part.mediaType}`,\n                });\n              }\n            }\n          }),\n          ...metadata,\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        let reasoning = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n          extra_content?: {\n            google?: {\n              thought_signature?: string;\n            };\n          };\n        }> = [];\n\n        for (const part of content) {\n          const partMetadata = getOpenAIMetadata(part);\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'reasoning': {\n              reasoning += part.text;\n              break;\n            }\n            case 'tool-call': {\n              // TODO: thoughtSignature should be abstracted once we add support for other providers\n              const thoughtSignature =\n                part.providerOptions?.google?.thoughtSignature;\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input),\n                },\n                ...partMetadata,\n                // Include extra_content for Google Gemini thought signatures\n                ...(thoughtSignature\n                  ? {\n                      extra_content: {\n                        google: {\n                          thought_signature: String(thoughtSignature),\n                        },\n                      },\n                    }\n                  : {}),\n              });\n              break;\n            }\n          }\n        }\n\n        messages.push({\n          role: 'assistant',\n          content: text,\n          ...(reasoning.length > 0 ? { reasoning_content: reasoning } : {}),\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          ...metadata,\n        });\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          if (toolResponse.type === 'tool-approval-response') {\n            continue;\n          }\n\n          const output = toolResponse.output;\n\n          let contentValue: string;\n          switch (output.type) {\n            case 'text':\n            case 'error-text':\n              contentValue = output.value;\n              break;\n            case 'execution-denied':\n              contentValue = output.reason ?? 'Tool execution denied.';\n              break;\n            case 'content':\n            case 'json':\n            case 'error-json':\n              contentValue = JSON.stringify(output.value);\n              break;\n          }\n\n          const toolResponseMetadata = getOpenAIMetadata(toolResponse);\n          messages.push({\n            role: 'tool',\n            tool_call_id: toolResponse.toolCallId,\n            content: contentValue,\n            ...toolResponseMetadata,\n          });\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return messages;\n}\n","import { LanguageModelV3FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAICompatibleFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV3FinishReason['unified'] {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'other';\n  }\n}\n","export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n"],"mappings":"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","names":["_a"]}